---
title: 从ACID到CAP／BASE
date: 2018-03-21 10:18:36
tags: CAP定理BASE理论
categories: 分布式 
---
本文是看《从Paxos到ZooKeeper分布式一致性原理与实践》-倪超 著。进行简单记录。
# ACID是什么？
事务(Transaction) 是由一系列对系统中数据进行访问与更新的操作组成的一个程序执行逻辑单元(Unit)，狭义上的事务特指数据库事务。一方面，当多个应用程序并发访问数据库时，事务可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。另一方面，事务为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持数据一致性的方法。  
事务具有四个特性，分别是原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持久性(Durability)，简称为事务对ACID特性。

# CAP是什么？
C:(Consistency)：一致性，A:(Availability)：可用性，P:(Partition tolerance)分区容错性  
一个分布式系统不可能同时满足CAP。
![这里写图片描述](/images/CAP.png)

<!--more-->

## 定理的应用：
|  放弃CAP定理  |  说明  |
| :---------------: |  :----: |
| 放弃P（分区容错性）  | 如果希望能够避免系统出现分区容错性问题，一种较为简单的做法是将所有的数据（或者仅仅是那些与事务相关的数据）都放在一个分布式节点上。这样的做法虽然无法100%地保证系统不会出错，但至少不会碰到由于网络分区带来的负面影响。但同时需要注意的是，放弃P的同时就意味着放弃了系统的可扩展性 |
| 放弃A（可用性）  | 相对于放弃"分区容错性"来说，放弃可用性则正好相反，其做法是一旦系统遇到网络分区或其他故障时，那么受到影响的服务需要等待一定的时间，因此在等待期间系统无法对外提供正常对服务，即不可用。 |
| 放弃C（一致性）  |  这里所说对放弃一致性，并不是完全不需要数据一致性，如果真是这样的话，那么系统的数据都是没有意义的，整个系统也是没有价值的。事实上，放弃一致性指的是放弃数据的强一致性，而保留数据的最终一致性。这样的系统无法保证数据保持实时的一致性，但是能够承诺的是，数据最终会达到一个一致的状态。这就引入了一个时间窗口的概念，具体多久能够到达数据一致取决于系统的设计，主要包括数据副本在不同节点之间的复制时间长短。 |
另一方面，需要明确的一点是，对于一个分布式系统而言，分区容错性可以说是一个最基本的要求。为什么这样说，其实很简单，因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构设计师往往需要把精力花在如何根据业务特点在C（一致性）和（A可用性）之间寻求平衡。  
# BASE理论是什么？
BASE是Basically Available (基本可用)、Soft state（软状态）和Eventually consistent（最终一致性） 三个短语的简写，是由来自eBay的架构师Dan Pritchett第一次明确提出，是对CAP中的一致性和可用性权衡的结构，其来源对于大规模互联网系统分布式实践的总结，是基于CAP定理逐步演进而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。

## 基本可用的典型例子：
* 相应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒查询出结果，但是出现故障之后，可能会增加1~2秒。  
* 功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促销购物高峰对时候，由于消费者的购物行为激增，为了保护购物的系统稳定性，部分消费者可能会被吸引到一个降级页面。
## 弱状态
若状态也称为软状态，和硬件状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。
## 最终一致性
### 因果一致性（Causal consistency）：
进程A在更新完某个数据项后通知栏进程B，那么进程B之后对数据项的访问都应该能够获取到进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系对进程C的数据访问则没有这样的限制。
### 读已之所写（Read your writes）:
进程A更新一个数据项之后，它自己总是能够访问到更新过对最新值，而不会看到旧值。也就是说，对于单个数据获取者来说，其读取到的数据，一定不会比自己上次写入的值旧。因此，读已之所写也可以看作是一种特殊的因果一致性。
### 会话一致性（Session consistency）:
会话一致性对系统数据的访问过程框定在了一个会话当中：系统能够保证在同一个有效的会话中实现"读已之所写"的一致性，也就是说，执行更新操作之后，可会能够在同一个会话中始终读取到该数据项对最新值。
### 单调读一致性(Monotonic read consistency)
单调读一致性是指如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。
### 单调写一致性（Monotonic write consistency）
单调写一致性是指，一个系统需要能够保证来自同一个进程的写操作被顺序的执行。  
## BASE小结
事实上，最终一致性并不是只有那些大型分布式系统才涉及的特性，许多现代的关系型数据库都采用了最终一致性模型。在现代关系型数据库中，大多都是会采用同步和异步方式来实现主备数据复制技术。在同步方式中，数据的复制过程通常是更新事务的一部分，因此在事务完成后，主备数据库的数据就会达到一致。而在异步方式中，备库的更新往往会存在延时，这取决于事务日志在主备数据库之间传输的时间长短，如果传输时间过长，或者甚至在日志传输过程中出现异常导致无法及时将事务应用到备库上，那么很显然，从备库中读取的数据是旧的，因此就会出现数据不一致的情况。当然，无论是采用多次重试还是人为数据订正，关系型数据库还是能够保证最终数据达到一致---这就是系统提供最终一致性保证的经典案例。   
总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性是相反的，它完全不同于ACID的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但是最终达到一致状态。但同时，在实际分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计的过程中，ACID特性与BASE理论往往又会结合在一起使用。



